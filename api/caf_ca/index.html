<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>Home - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-caf_ca_ca_main.html">caf_ca/ca_main</a></li><li><a href="module-caf_ca_gen_ca.html">caf_ca/gen_ca</a><ul class='methods'><li data-type='method'><a href="module-caf_ca_gen_ca.html#__ca_destroy__">__ca_destroy__</a></li><li data-type='method'><a href="module-caf_ca_gen_ca.html#__ca_getAppName__">__ca_getAppName__</a></li><li data-type='method'><a href="module-caf_ca_gen_ca.html#__ca_getName__">__ca_getName__</a></li><li data-type='method'><a href="module-caf_ca_gen_ca.html#__ca_isJustCreated__">__ca_isJustCreated__</a></li><li data-type='method'><a href="module-caf_ca_gen_ca.html#__ca_process__">__ca_process__</a></li><li data-type='method'><a href="module-caf_ca_gen_ca.html#__ca_progress__">__ca_progress__</a></li><li data-type='method'><a href="module-caf_ca_gen_ca.html#__ca_pull__">__ca_pull__</a></li><li data-type='method'><a href="module-caf_ca_gen_ca.html#__ca_pulse__">__ca_pulse__</a></li><li data-type='method'><a href="module-caf_ca_gen_ca.html#__ca_setJustCreated__">__ca_setJustCreated__</a></li></ul></li><li><a href="module-caf_ca_gen_handler.html">caf_ca/gen_handler</a><ul class='methods'><li data-type='method'><a href="module-caf_ca_gen_handler.html#__ca_pulse__">__ca_pulse__</a></li><li data-type='method'><a href="module-caf_ca_gen_handler.html#__ca_upgrade__">__ca_upgrade__</a></li><li data-type='method'><a href="module-caf_ca_gen_handler.html#__external_ca_destroy__">__external_ca_destroy__</a></li><li data-type='method'><a href="module-caf_ca_gen_handler.html#__external_ca_multi__">__external_ca_multi__</a></li><li data-type='method'><a href="module-caf_ca_gen_handler.html#__external_ca_touch__">__external_ca_touch__</a></li></ul></li><li><a href="module-caf_ca_main.html">caf_ca/main</a><ul class='methods'><li data-type='method'><a href="module-caf_ca_main.html">getModule</a></li></ul></li><li><a href="module-caf_ca_plug_ca_handler.html">caf_ca/plug_ca_handler</a></li><li><a href="module-caf_ca_plug_ca_inqueue.html">caf_ca/plug_ca_inqueue</a><ul class='methods'><li data-type='method'><a href="module-caf_ca_plug_ca_inqueue.html#getQueue">getQueue</a></li><li data-type='method'><a href="module-caf_ca_plug_ca_inqueue.html#process">process</a></li><li data-type='method'><a href="module-caf_ca_plug_ca_inqueue.html#progress">progress</a></li></ul></li><li><a href="module-caf_ca_proxy_handler.html">caf_ca/proxy_handler</a></li><li><a href="module-caf_ca_proxy_inqueue.html">caf_ca/proxy_inqueue</a><ul class='methods'><li data-type='method'><a href="module-caf_ca_proxy_inqueue.html#delayMethod">delayMethod</a></li><li data-type='method'><a href="module-caf_ca_proxy_inqueue.html#queueLength">queueLength</a></li></ul></li></ul><h3>Externals</h3><ul><li><a href="external-caf_cli.html">caf_cli</a></li><li><a href="external-caf_components.html">caf_components</a></li><li><a href="external-caf_components_gen_plug_ca.html">caf_components/gen_plug_ca</a></li><li><a href="external-caf_components_gen_proxy.html">caf_components/gen_proxy</a></li><li><a href="external-caf_components_gen_transactional.html">caf_components/gen_transactional</a></li><li><a href="external-caf_pubsub.html">caf_pubsub</a></li><li><a href="external-caf_security.html">caf_security</a></li><li><a href="external-caf_session.html">caf_session</a></li><li><a href="external-caf_sharing.html">caf_sharing</a></li></ul><h3><a href="global.html">Global</a></h3>
</nav>

<div id="main">
    

    



    


    <section class="package">
        <h3>caf_ca 0.4.5</h3>		
    </section>









    



    <section class="readme usertext">
        <article><h1>Caf.js</h1>
<p>Co-design cloud assistants with your web app and IoT devices.</p>
<p>See https://www.cafjs.com</p>
<h2>Library for creating CAs</h2>
<p><a href="https://github.com/cafjs/caf_ca/actions/workflows/push.yml"><img src="https://github.com/cafjs/caf_ca/actions/workflows/push.yml/badge.svg" alt="Build Status"></a></p>
<p>This library provides components to create a CA (Cloud Assistant).</p>
<p>A CA is an Actor, in the spirit of an Erlang/OTP <code>gen_server</code>, with a queue that serializes message processing, a location-independent name, some private state, and the ability to change behavior, or interact with other CAs.</p>
<p>A CA processes a message in a transaction. External interactions are mediated by transactional plugins, and delayed until the message commits. Any non-commited changes to its internal state can be rolled back if errors are detected. State changes and pending interactions always checkpoint with a remote service before commiting. See <a href="external-caf_components_gen_transactional.html">external:caf_components/gen_transactional</a> for details.</p>
<p>This makes it safe to kill, <strong>at any time</strong>, a node.js process hosting thousands of  CAs. The expectations of the external world are always consistent with the recovered CAs.</p>
<p>In fact, our favorite load-balancing strategy is to just kill hot processes, and randomly spread recovered CAs to other instances.</p>
<h3>Hello World (see <code>examples/helloworld</code>)</h3>
<p>CA methods are <strong>always</strong> asynchronous methods. They can be implemented using the <code>async/await</code> pattern, or using standard callbacks. In the first case we emulate the callback by returning an array with an error/data pair.</p>
<p>When the method returns this array, or invokes the callback as a tail call, the framework knows that the message has been fully processed, and your application is ready for the next one. This enforces message serialization, even if we <code>await</code> while processing a message, eliminating races.</p>
<p>Never throw in a method to propagate an application error. An unhandled exception closes the client session. Instead, return the error as the first argument of the array (or callback), and the client will process it inline, without closing the session. This strategy makes it easier to find programming errors.</p>
<p>CAs have two sets of methods:</p>
<ul>
<li><em>internal:</em> always prefixed by <code>__ca_</code> and called by the framework.</li>
<li><em>external:</em> all the others, called remotely by the client library.</li>
</ul>
<pre class="prettyprint source"><code>exports.methods = {
    async __ca_init__() {
        this.state.counter = 0;
        return [];
    },
    async increment() {
        this.state.counter = this.state.counter + 1;
        return [null, this.state.counter];
    }
};
</code></pre>
<p>The <em>internal</em> method <code>__ca_init__</code> is called by the framework just once, initializing the state of the CA.</p>
<p>The object property <code>this.state</code> should contain a JSON-serializable value, and is managed transactionally as described above.</p>
<p>In contrast, <code>this.scratch</code> can contain anything, but is not checkpointed or rolled back.</p>
<p>A CA is a sealed object, and application code should not try to add any properties outside <code>this.state</code> or <code>this.scratch</code>.</p>
<p><em>External</em> methods, such as <code>increment</code>, are called by the client library, see <code>client.js</code> in the <code>examples</code> directory and <a href="external-caf_cli.html">external:caf_cli</a>.</p>
<h3>Crashy Counter (see <code>examples/crashy</code>)</h3>
<p>Let's look at a more interesting CA.</p>
<pre class="prettyprint source"><code>var setTimeoutPromise = util.promisify(setTimeout);
exports.methods = {
     ...
    async increment(crash) {
        var oldValue = this.state.counter;
        this.state.counter = this.state.counter + 1;
        await setTimeoutPromise(1000);
        if (crash === 'Oops') {
            return [new Error('Oops')];// Case 1
        } else if (crash === 'Really Oops') {
            throw new Error('Really Oops'); // Case 2
        } else {
            assert(this.state.counter === (oldValue + 1)); // Assertion 1
            return [null, this.state.counter]; // Case 3
        }
    }
}
</code></pre>
<p><em>Assertion 1</em> is always true, even if <code>increment</code> is called by many concurrent clients. The CA serializes the requests, and will patiently wait for the timeout  before processing the next one.</p>
<p>The client can receive three different type of responses:</p>
<ul>
<li>
<p><em>Case 1</em> An application error propagated by the client's callback. Changes to <code>this.state.counter</code> are rolled back.</p>
</li>
<li>
<p><em>Case 2</em> An unhandled error, assumed to be an application bug, that closes the client session with an error. The framework also recovers from this error, with changes to <code>this.state.counter</code> being rolled back.</p>
</li>
<li>
<p><em>Case 3</em> A new counter value returned in the client's callback.</p>
</li>
</ul>
<h3>Autonomous Behavior (see <code>examples/autonomous</code>)</h3>
<pre class="prettyprint source"><code>exports.methods = {
    ...
    async __ca_resume__(cp) {
        this.$.log.debug('Resuming with counter:' + cp.state.counter);
        return [];
    },
    async __ca_pulse() {
        this.state.counter = this.state.counter + 1;
        return [];
    }
    ...
}
</code></pre>
<p>Declaring a method <code>__ca_pulse__</code> guarantees that the framework will periodically invoke it, enabling autonomous behavior.</p>
<p>The method <code>__ca_resume__</code> is called every time we reload the CA state from a checkpoint <code>cp</code>. It allows customization after migration or failure recovery.</p>
<h4>Plugins</h4>
<p>A CA extends its capabilities with a plugin architecture. <code>Caf.js</code> uses a component model <a href="external-caf_components.html">external:caf_components</a> to describe plugins with a configuration file <code>ca.json</code>. See <code>lib/ca.json</code> for an example.</p>
<p>A plugin is exposed to application code with a security proxy (see <a href="external-caf_components_gen_proxy.html">external:caf_components/gen_proxy</a>). These proxies are properties of the object <code>this.$</code>.</p>
<p>For example, the following CA uses two proxies: <code>log</code>, a logger plugin, and <code>session</code>, a plugin providing persistent sessions (see <a href="external-caf_session.html">external:caf_session</a>).</p>
<pre class="prettyprint source"><code>exports.methods = {
    ...
    async __ca_pulse__() {
        this.state.counter = this.state.counter + 1;
        if (this.state.counter % 5 === 0) {
            this.$.log.debug('counter %5 === 0 with ' + this.state.counter);
            this.$.session.notify([this.state.counter]);
        }
        return [];
    }
    ...
}
</code></pre>
<h3>Versioning (see <code>examples/versioning</code>)</h3>
<p>(This example uses callbacks instead of <code>async/await</code>. Both are first-class citizens of the platform, but if you use node 8 or newer, we recommend <code>async/await</code> because programs are easier to read.)</p>
<p>When the implementation of a CA changes, the checkpointed state may be incompatible with the new code.</p>
<p>We use <code>semver</code> conventions, and the configuration property <code>stateVersion</code>, to track versions of <code>this.state</code>.</p>
<p>The value of <code>stateVersion</code> is stored in the checkpoint as property <code>this.state.__ca_version__</code>. When a CA resumes, it compares <code>this.state.__ca_version__</code> from the checkpoint with the desired value of <code>stateVersion</code>.</p>
<p>By default, if <code>stateVersion</code> satisfies semver expression <code>^this.state.__ca_version__</code> the state transparently upgrades. Otherwise, loading fails.</p>
<p>To avoid this failure, the CA needs to provide an implementation of <code>__ca_upgrade__</code>, a method called before processing any messages. This method knows how to upgrade <code>this.state</code> safely.</p>
<p>For example, changing <code>this.state.counter</code> to <code>this.state.myCounter</code>:</p>
<pre class="prettyprint source"><code>exports.methods = {
    ...
    __ca_upgrade__: function(newVersion, cb) {
        var oldVersion = this.state.__ca_version__;
        if (semver.valid(oldVersion) && semver.valid(newVersion) &&
            semver.satisfies(newVersion, '^' + oldVersion)) {
            this.$.log.debug('update: minor version:automatic update of state');
        } else {
            // do some magic to this.state
            this.$.log.debug('update: major version mismatch ' + newVersion );
            this.state.myCounter = this.state.counter;
            delete this.state.counter;
        }
        this.state.__ca_version__ = newVersion;
        cb(null);
    },
    increment: function(cb) {
        this.state.myCounter = this.state.myCounter + 1;
        cb(null, this.state.myCounter);
    }
    ...
}
</code></pre>
<h3>Much More...</h3>
<ul>
<li>
<p>Sharing Actors <a href="external-caf_sharing.html">external:caf_sharing</a></p>
</li>
<li>
<p>Security <a href="external-caf_security.html">external:caf_security</a></p>
</li>
<li>
<p>Persistent Sessions <a href="external-caf_session.html">external:caf_session</a></p>
</li>
<li>
<p>Pub/Sub <a href="external-caf_pubsub.html">external:caf_pubsub</a></p>
</li>
</ul></article>
    </section>






    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.10</a> on Thu Feb 17 2022 19:25:07 GMT-0800 (Pacific Standard Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>