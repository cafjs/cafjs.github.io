<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Home</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Home</h1>

    



    


    <h3>caf_pubsub 0.2.7</h3>










    




    <section>
        <article><h1>CAF.js (Cloud Assistant Framework)</h1><p>Co-design permanent, active, stateful, reliable cloud proxies with your web app and gadgets.</p>
<p>See http://www.cafjs.com</p>
<h2>CAF Lib publish/subscribe</h2><p><a href="http://ci.cafjs.com/cafjs/caf_pubsub"><img src="http://ci.cafjs.com/api/badges/cafjs/caf_pubsub/status.svg" alt="Build Status"></a></p>
<p>This repository contains a CAF library that implements a publish/subscribe bus using, for example, a <code>Redis</code> backend.</p>
<p>There are two types of channels:</p>
<ul>
<li><p>A <em>private channel</em> name is prefixed by the CA name, i.e., <code>&lt;ca_name&gt;-&lt;whatever&gt;</code>, and only that CA can publish messages.</p>
</li>
<li><p>A <em>forum channel</em> has a name of the form <code>forum-&lt;whatever&gt;</code>, and anybody can publish to it. However, subscribers can filter publishers using method ACLs, since pubsub messages are always processed by invoking a CA method. This method is chosen by the subscriber.</p>
</li>
</ul>
<p>Currently, anybody can subscribe to a channel if they know its name, and we recommend to use hard to guess channel names to limit visibility.</p>
<p>The delivery guarantees depend on the pubsub backend service. <code>Redis</code>, for example, is best effort. However, when the plugin has committed to publish a message, it will retry after a CA or node.js process crash.</p>
<p>A pubsub service complements well a <code>SharedMap</code> (see <a href="external-caf_sharing.html">external:caf_sharing</a>). <code>SharedMaps</code> are silently updated, and this makes them very efficient when shared by many CAs. Messages generated by a pubsub service are processed by subscribed CAs and, for example, can trigger external actions. By combining them, we can get the right mix of silent updates vs external actions.</p>
<p>CAF.js discourages <code>point-to-point</code> communication between CAs. At the network infrastructure level, <code>point-to-point</code> becomes <code>all-to-all</code> very quickly, limiting the scalability of the system.</p>
<p>Similar to MPI collective calls, applications should expose higher-level communication patterns. These patterns can scale better with specialized services, such as <code>SharedMap</code> or <code>pubsub</code>.</p>
<p>However, if you really need <code>point-to-point</code>, you can always use a <em>private pubsub channel</em>, or write a new plugin...</p>
<h3>Hello World (see <code>examples/helloworld</code>)</h3><p>The following example has a privileged CA, i.e., <code>admin</code>, that regularly publishes messages in a private channel. CAs with the same owner subscribe to this channel, and the handler function notifies clients using sessions (see <a href="external-caf_session.html">external:caf_session</a>).</p>
<pre class="prettyprint source"><code>exports.methods = {
    __ca_init__: function(cb) {
        this.state.counter = 0;
        this.$.pubsub.subscribe(masterChannel(this), 'handleMessage');
        cb(null);
    },
    __ca_pulse__: function(cb) {
        if (isAdmin(this)) {
            this.state.counter = this.state.counter + 1;
            this.$.pubsub.publish(masterChannel(this),
                                  'Counter: ' + this.state.counter);
        }
        cb(null);
    },
    handleMessage: function(topic, msg, cb) {
        this.$.log && this.$.log.debug('Got ' + msg);
        this.$.session.notify([msg]);
        cb(null);
    }
}</code></pre><p>A couple of helper functions for naming:</p>
<pre class="prettyprint source"><code>var ADMIN_CA = 'admin';
var ADMIN_CHANNEL = 'myNews';
var isAdmin = function(self) {
    var name = self.__ca_getName__();
    return (caf.splitName(name)[1] === ADMIN_CA);
};
var masterChannel = function(self) {
    var name = self.__ca_getName__();
    return caf.joinName(caf.splitName(name)[0], ADMIN_CA, ADMIN_CHANNEL);
};</code></pre><p>See the client code in <code>examples/helloworld/client1.js</code></p>
<h2>API</h2><p>See <a href="module-caf_pubsub_proxy_pubsub.html">module:caf_pubsub/proxy_pubsub</a></p>
<h2>Configuration</h2><h3>framework.json</h3><p>See <a href="module-caf_pubsub_plug_pubsub.html">module:caf_pubsub/plug_pubsub</a></p>
<h3>ca.json</h3><p>See <a href="module-caf_pubsub_plug_ca_pubsub.html">module:caf_pubsub/plug_ca_pubsub</a></p></article>
    </section>






</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-caf_pubsub_main.html">caf_pubsub/main</a></li><li><a href="module-caf_pubsub_plug_ca_pubsub.html">caf_pubsub/plug_ca_pubsub</a></li><li><a href="module-caf_pubsub_plug_pubsub.html">caf_pubsub/plug_pubsub</a></li><li><a href="module-caf_pubsub_proxy_pubsub.html">caf_pubsub/proxy_pubsub</a></li></ul><h3>Externals</h3><ul><li><a href="external-caf_components_gen_plug.html">caf_components/gen_plug</a></li><li><a href="external-caf_components_gen_plug_ca.html">caf_components/gen_plug_ca</a></li><li><a href="external-caf_components_gen_proxy.html">caf_components/gen_proxy</a></li><li><a href="external-caf_session.html">caf_session</a></li><li><a href="external-caf_sharing.html">caf_sharing</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Mon Dec 19 2016 02:13:36 GMT-0800 (PST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>