<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Home</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Home</h1>

    



    


    <h3>caf_components 0.3.1</h3>










    




    <section>
        <article><h1>CAF.js (Cloud Assistant Framework)</h1><p>Co-design permanent, active, stateful, reliable cloud proxies with your web app and gadgets.</p>
<p>See http://www.cafjs.com</p>
<h2>CAF Components</h2><p><a href="http://ci.cafjs.com/cafjs/caf_components"><img src="http://ci.cafjs.com/api/badges/cafjs/caf_components/status.svg" alt="Build Status"></a></p>
<p>This library configures and manages a hierarchy of asynchronously created components. Asynchronous constructors are useful when components need configuration data from an external service, and we do not want to block the main loop.</p>
<p>It has no dependencies with other CAF.js packages, and we hope that it will be useful to other frameworks. In CAF.js <strong>everything</strong> is built with components.</p>
<p>This library was inspired by the SmartFrog (Java) framework https://en.wikipedia.org/wiki/SmartFrog and Erlang/OTP supervision trees.</p>
<h3>Hello World</h3><p>We use JSON to describe components. For example, file <code>hello.json</code> contains:</p>
<pre class="prettyprint source"><code>{
    &quot;module&quot;: &quot;./hello&quot;,
    &quot;name&quot; : &quot;foo&quot;,
    &quot;env&quot; : {
        &quot;msg&quot; : &quot;Hello World!&quot;
    }
}</code></pre><p>where <code>env</code> is a set of properties to configure the component, <code>name</code> is a key to register the new component in a local context, and <code>module</code> an implementation for the component. In particular, the <code>hello.js</code> implementation file looks like this:</p>
<pre class="prettyprint source"><code>exports.newInstance = function($, spec, cb) {
    cb(null, {
        hello() {
            console.log(spec.name + ':' + spec.env.msg);
        },
        __ca_checkup__(data, cb0) {
            cb0(null);
        },
        __ca_shutdown__(data, cb0) {
            cb0(null);
        }
    });
};</code></pre><p>An implementation exports an asynchronous factory method called <code>newInstance</code>. This method takes a local context <code>$</code>, a parsed configuration description <code>spec</code>, and a callback <code>cb</code> that returns the new component or an error.</p>
<p>In node 8 or later we can also use <code>async/await</code> to implement the asynchronous factory method:</p>
<pre class="prettyprint source"><code>exports.newInstance = async function($, spec) {
    var that = {
        hello() {
            console.log(spec.name + ':' + spec.env.msg);
        },
        __ca_checkup__(data, cb0) {
            cb0(null);
        },
        __ca_shutdown__(data, cb0) {
            cb0(null);
        }
    };
    return [null, that];
};</code></pre><p>returning an array with an error/component pair.</p>
<p>The component needs to implement two methods:</p>
<ul>
<li><code>__ca_checkup__</code> returns a callback error if there is something wrong with the component.</li>
<li><code>__ca_shutdown__</code> sets the component in a disabled state. This function should be idempotent and irrecoverable.</li>
</ul>
<p>See <a href="module-caf_components_gen_component.html">module:caf_components/gen_component</a> for a discussion of checkup and shutdown.</p>
<p>What we need now is a way to link the JSON description with the implementation:</p>
<pre class="prettyprint source"><code>var main = require('caf_components');
main.load(null, null, 'hello.json', [module], function(err, $) {
    if (err) {
        console.log(main.myUtils.errToPrettyStr(err));
    } else {
        $.foo.hello();
    }
});</code></pre><p>The method <code>main.load</code> is loading and parsing the json description, and using that description to instantiate and register a component in the <code>$</code> context. Since the first argument, i.e., the initial local context, was <code>null</code>, it will create a fresh <code>$</code> context.</p>
<p>Why do we need to provide <code>module</code>? The method <code>main.load</code> will execute a command like <code>require('./hello').newInstance(...)</code>, and it needs to know the directory paths to look for <code>hello.json</code> and <code>hello.js</code>. In this case, we assume that they are all in the same directory, but we can pass an array of <code>module</code> objects to provide alternative locations. See <a href="module-caf_components_gen_loader.html">module:caf_components/gen_loader</a> for details.</p>
<p>If we want to create another instance with a different configuration:</p>
<pre class="prettyprint source"><code>var main = require('caf_components');
main.load(null, {name: 'bar', env: {msg: 'Bye!'}}, 'hello.json', [module],
    function(err, $) {
        if (err) {
            console.log(main.myUtils.errToPrettyStr(err));
        } else {
            $.bar.hello();
        }
});</code></pre><p>and, before creating the component, <code>main.load</code> merges the configuration in the second argument with the contents of <code>hello.json</code>.</p>
<h3>Hierarchy</h3><p>Let's add a hierarchy of components to <code>hello.json</code>:</p>
<pre class="prettyprint source"><code>{
    &quot;module&quot;: &quot;caf_components#supervisor&quot;,
    &quot;name&quot; : &quot;top&quot;,
    &quot;env&quot; : {
        &quot;maxRetries&quot; : 10,
        &quot;retryDelay&quot; : 1000,
        &quot;dieDelay&quot; : 100,
        &quot;maxHangRetries&quot; : 1,
        &quot;interval&quot; : 1000
    },
    &quot;components&quot;: [
        {
            &quot;module&quot;: &quot;caf_components#plug_log&quot;,
            &quot;name&quot; : &quot;log&quot;,
            &quot;env&quot; : {
                &quot;logLevel&quot; : &quot;DEBUG&quot;
            }
        },
        {
            &quot;module&quot;: &quot;./hello&quot;,
            &quot;name&quot; : &quot;foo&quot;,
            &quot;env&quot; : {
                &quot;msg&quot; : &quot;Hello World!&quot;
            }
        }
    ]
}</code></pre><p>A package can provide factory methods for different component types. We add an access indirection by using the separator <code>#</code>. For example, <code>caf_components#supervisor</code> is loaded as <code>require(&quot;caf_components&quot;).supervisor.newInstance(..)</code>.</p>
<p>Initialization of a hierarchy is always sequential, respecting array order, and ensuring that a parent component only registers after its children are properly initialized. During shutdown we do the opposite, unregistering the parent component asap, and reversing array order.</p>
<p>This means that we can respect initialization dependencies by ordering components in the description. For example, <code>hello.js</code> can safely use the logging component at initialization time:</p>
<pre class="prettyprint source"><code>exports.newInstance = function($, spec, cb) {
    $.log.debug('Initializing hello');
    cb(null, {
        hello: function() {
            console.log(spec.name + ':' + spec.env.msg);
        },
        __ca_checkup__: function(data, cb0) {
            cb0(null);
        },
        __ca_shutdown__: function(data, cb0) {
            cb0(null);
        }
    });
};</code></pre><p>What if we have more than two levels? Each parent component (see <a href="module-caf_components_gen_container.html">module:caf_components/gen_container</a> and <a href="module-caf_components_gen_dynamic_container.html">module:caf_components/gen_dynamic_container</a>) creates a fresh <code>$</code> context for its children, but it also registers a reference <code>_</code> in that context to the top component. This top reference helps them to navigate the hierarchy. For example, we can also refer to the logging component as <code>$._.$.log</code> since its parent is the top component.</p>
<p>The calling program is modified slightly to use the top reference:</p>
<pre class="prettyprint source"><code>var main = require('caf_components');
main.load(null, null, 'hello.json', [module], function(err, $) {
    if (err) {
        console.log(main.myUtils.errToPrettyStr(err));
    } else {
        $._.$.foo.hello(); // or $.top.$.foo.hello()
    }
});</code></pre><p>The top level supervisor (see <a href="module-caf_components_supervisor.html">module:caf_components/supervisor</a>) forces components with children to periodically check their health, and take local recovery actions when they fail. When local recovery actions do not work, the failure bubbles up until it reaches the root component. This component typically just logs an error message, and exits the process with an error code. At that point an external recovery mechanism should take over.</p>
<h3>Component Description Transforms</h3><p>In a cloud deployment scenario the usage model of component descriptions is fairly predictable:</p>
<ol>
<li>Start with a base template that defines a standard hierarchy of components for the service.</li>
<li>Modify the template by adding, removing, or patching components.</li>
<li>Create several instances of the modified template by passing different arguments.</li>
<li>Propagate instance arguments to internal components.</li>
<li>Fill in missing values by reading properties from the environment.</li>
</ol>
<p>We have already described how to provide instance arguments to <code>main.load</code>. Let's describe how to modify templates, propagate arguments with linking, and specify environment properties with defaults.</p>
<h4>Templates</h4><p>If we want to use the previous <code>hello.json</code> description as a template, and swap
component <code>foo</code> by a new component <code>bar</code>, we just create a file with name <code>&lt;fileNameBase&gt;++.json</code>, i.e., <code>hello++.json</code>:</p>
<pre class="prettyprint source"><code>{
    &quot;name&quot; : &quot;top&quot;,
     &quot;components&quot;: [
         {
             &quot;module&quot;: null,
             &quot;name&quot; : &quot;foo&quot;
         },
         {
             &quot;module&quot;: &quot;./hello&quot;,
             &quot;name&quot; : &quot;bar&quot;,
             &quot;env&quot; : {
                 &quot;msg&quot; : &quot;Bye!&quot;
             }
         }
     ]
}</code></pre><p>and this description merges with the original by following simple rules:</p>
<ul>
<li>Use <code>name</code> to identify matching components.</li>
<li>Assign <code>null</code> to <code>module</code> to delete a component.</li>
<li>Components like <code>bar</code> that do not match existing ones are inserted just after the last changed one, i.e., <code>foo</code>.</li>
</ul>
<p>See <a href="module-caf_components_templateUtils.html">module:caf_components/templateUtils</a> for details.</p>
<h4>Linking</h4><p>We want to parameterize descriptions without knowing the configuration details of internal components. Arguments only modify the top level component, and we specify links to properties of this component with the <code>$._.env.</code> prefix. For example, in <code>hello++.json</code>:</p>
<pre class="prettyprint source"><code>{
    &quot;name&quot; : &quot;top&quot;,
    &quot;env&quot;: {
        &quot;myLogLevel&quot;: &quot;DEBUG&quot;
    },
    &quot;components&quot;: [
         {
             &quot;name&quot; : &quot;log&quot;,
             &quot;env&quot; : {
                 &quot;logLevel&quot; : &quot;$._.env.myLogLevel&quot;
             }
         }
     ]
}</code></pre><p>and now we can change the logging level with:</p>
<pre class="prettyprint source"><code>main.load(null, {env: {myLogLevel: 'WARN'}}, 'hello.json', ...</code></pre><h4>Properties</h4><p>We use the reserved <code>process.env.</code> prefix for values that come  from the environment. We can also provide default values using the string separator <code>||</code>, and any characters after it will be parsed as JSON. If parsing fails, we default to a simple string, avoiding the JSON requirement of quoting all strings. For example:</p>
<pre class="prettyprint source"><code>{
    &quot;name&quot; : &quot;top&quot;,
    &quot;env&quot;: {
        &quot;myLogLevel&quot;: &quot;process.env.MY_LOG_LEVEL||DEBUG&quot;,
        &quot;somethingElse&quot;: &quot;process.env.SOMETHING_ELSE||{\&quot;goo\&quot;:2}&quot;
    },
    &quot;components&quot;: [
         {
             &quot;name&quot; : &quot;log&quot;,
             &quot;env&quot; : {
                 &quot;logLevel&quot; : &quot;$._.env.myLogLevel&quot;
             }
         }
     ]
}</code></pre><p>and now we can change the logging level by setting the environment variable <code>MY_LOG_LEVEL</code></p></article>
    </section>






</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-caf_components_containerUtils.html">caf_components/containerUtils</a></li><li><a href="module-caf_components_gen_component.html">caf_components/gen_component</a></li><li><a href="module-caf_components_gen_container.html">caf_components/gen_container</a></li><li><a href="module-caf_components_gen_cron.html">caf_components/gen_cron</a></li><li><a href="module-caf_components_gen_dynamic_container.html">caf_components/gen_dynamic_container</a></li><li><a href="module-caf_components_gen_loader.html">caf_components/gen_loader</a></li><li><a href="module-caf_components_gen_plug.html">caf_components/gen_plug</a></li><li><a href="module-caf_components_gen_plug_ca.html">caf_components/gen_plug_ca</a></li><li><a href="module-caf_components_gen_proxy.html">caf_components/gen_proxy</a></li><li><a href="module-caf_components_gen_supervisor.html">caf_components/gen_supervisor</a></li><li><a href="module-caf_components_gen_transactional.html">caf_components/gen_transactional</a></li><li><a href="module-caf_components_main.html">caf_components/main</a></li><li><a href="module-caf_components_myUtils.html">caf_components/myUtils</a></li><li><a href="module-caf_components_naming.html">caf_components/naming</a></li><li><a href="module-caf_components_plug_ca_log.html">caf_components/plug_ca_log</a></li><li><a href="module-caf_components_plug_log.html">caf_components/plug_log</a></li><li><a href="module-caf_components_proxy_log.html">caf_components/proxy_log</a></li><li><a href="module-caf_components_supervisor.html">caf_components/supervisor</a></li><li><a href="module-caf_components_templateUtils.html">caf_components/templateUtils</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Sat Feb 03 2018 00:52:30 GMT-0800 (PST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>