<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: aggregates.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: aggregates.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*!
Copyright 2014 Hewlett-Packard Development Company, L.P.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

'use strict';
/**
 * Authorization rule that implements linked local namespaces with
 *  an `AggregateMap` (see {@link external:caf_sharing/AggregateMap}).
 *
 * @module caf_security/aggregates
 */
var crypto = require('crypto');
var json_rpc = require('caf_transport').json_rpc;

var AGGREGATE_RULE_TYPE = exports.AGGREGATE_RULE_TYPE = 'caf.aggregateRule';
var HASH_ALGO = 'md5';

var checkAggregateRule = function(rule) {
    if (rule.type !== AGGREGATE_RULE_TYPE) {
        var err = new Error('Invalid aggregate rule');
        err.rule = rule;
        throw err;
    }
};

/**
 * Computes a content-based identifier for a rule.
 *
 * @see {@link module:caf_security/proxy_security#addRule}.
 *
 * @param {caf.rule} rule A rule.
 * @return {string} A unique identifier based on the contents of that rule.
 * @throws {Error} Invalid rule.
 *
 * @memberof! module:caf_security/aggregates
 * @alias computeRuleId
 *
 */
exports.computeRuleId = function(rule) {
    checkAggregateRule(rule);

    var p = [AGGREGATE_RULE_TYPE, rule.alias, rule.methods || null];
    var pStr = JSON.stringify(p);
    return crypto.createHash(HASH_ALGO).update(pStr).digest('hex');
};

/**
 * Preprocess an array of rules for quick authorization checks.
 *
 * @param {Object} ca The CA that contains the security plugin.
 * @param {Array.&lt;caf.rule>} rules A set of rules to pre-process.
 *
 * @return {caf.ruleEngine} An engine to speed up checks.
 *
 * @memberof! module:caf_security/aggregates
 * @alias newRuleEngine
 */
exports.newRuleEngine = function(ca, rules) {
    var rE = {};
    // inverse lookup table
    var mToMap = {};

    rules = rules || [];

    rules.forEach(function(rule) {
        checkAggregateRule(rule);
        var method = (rule.methods ? rule.methods : '*');
        method = (Array.isArray(method) ? method : [method]);
        method.forEach(function(m) {
            var value = mToMap[m];
            value = (value ? value : []);
            value.push(rule.alias);
            mToMap[m] = value;
        });
    });

    var isAuthorizedOne = function($$, aggArray, name) {
        if (Array.isArray(aggArray)) {
            return aggArray.some(function(x) {
                var agg = $$[x];
                if (agg) {
                    return (agg.getAll(name).length > 0);
                } else {
                    return false;
                }
            });
        } else {
            return false;
        }
    };

    rE.isAuthorized = function(caOwner, caLocalName, method) {
        if (ca.$.sharing) {
            var fullName = json_rpc.joinName(caOwner, caLocalName);
            var $$ = ca.$.sharing.$.proxy.$;
            var wild = mToMap['*'];
            if (wild) {
                if (isAuthorizedOne($$, wild, caOwner)) {
                    return true;
                }
                if (isAuthorizedOne($$, wild, fullName)) {
                    return true;
                }
            }
            var m = mToMap[method];
            if (m) {
                if (isAuthorizedOne($$, m, caOwner)) {
                    return true;
                }
                if (isAuthorizedOne($$, m, fullName)) {
                    return true;
                }
            }
        }
        return false;
    };

    return rE;
};

/**
 * Checks whether a CA is authorized to make a method call.
 *
 * @param {string} caOwner The owner of the calling CA.
 * @param {string} caLocalName The local name of the calling CA.
 * @param {string} method A method to authorize.
 * @param {caf.ruleEngine} rE A data structure to speed up checks.
 *
 * @return {boolean} True if authorized.
 *
 * @memberof! module:caf_security/aggregates
 * @alias isAuthorized
 */
exports.isAuthorized = function(caOwner, caLocalName, method, rE) {
    return rE.isAuthorized(caOwner, caLocalName, method);
};


/**
 * Constructor for a rule that uses an `AggregateMap` to represent a linked
 * local namespace.
 *
 * Note that aggregate rules are only active if the corresponding
 * `AggregateMap` has been added using the `caf_sharing` plugin.
 *
 *  @see {@link external:caf_sharing}
 *  @see {@link module:caf_security/proxy_security#addRule}.
 *
 *  @param {(Array.&lt;string>|string)=} methods Methods to enable.
 *  @param {string} aggregateMapAlias The alias that we used to
 * instantiate the `AggregateMap`.
 *
 *  @return {caf.rule} An authorization rule.
 *
 * @memberof! module:caf_security/aggregates
 * @alias newAggregateRule
 */
exports.newAggregateRule = function(methods, aggregateMapAlias) {
    var result = {type: AGGREGATE_RULE_TYPE};
    if (methods) {
        result.methods = methods;
    }
    result.alias = aggregateMapAlias;
    return result;
};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-caf_security_aggregates.html">caf_security/aggregates</a></li><li><a href="module-caf_security_main.html">caf_security/main</a></li><li><a href="module-caf_security_plug_ca_security.html">caf_security/plug_ca_security</a></li><li><a href="module-caf_security_plug_security.html">caf_security/plug_security</a></li><li><a href="module-caf_security_proxy_security.html">caf_security/proxy_security</a></li><li><a href="module-caf_security_rules.html">caf_security/rules</a></li><li><a href="module-caf_security_tokens.html">caf_security/tokens</a></li><li><a href="module-caf_security_utils.html">caf_security/utils</a></li></ul><h3>Externals</h3><ul><li><a href="external-caf_components_gen_plug.html">caf_components/gen_plug</a></li><li><a href="external-caf_components_gen_plug_ca.html">caf_components/gen_plug_ca</a></li><li><a href="external-caf_components_gen_proxy.html">caf_components/gen_proxy</a></li><li><a href="external-caf_sharing.html">caf_sharing</a></li><li><a href="external-caf_sharing_AggregateMap.html">caf_sharing/AggregateMap</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Tue Dec 20 2016 01:57:55 GMT-0800 (PST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
