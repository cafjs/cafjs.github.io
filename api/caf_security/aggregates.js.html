<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: aggregates.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: aggregates.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>// Modifications copyright 2020 Caf.js Labs and contributors
/*!
Copyright 2014 Hewlett-Packard Development Company, L.P.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

'use strict';
/**
 * Authorization rule that implements linked local namespaces with
 *  an `AggregateMap` (see {@link external:caf_sharing/AggregateMap}).
 *
 * @module caf_security/aggregates
 */
const crypto = require('crypto');
const json_rpc = require('caf_transport').json_rpc;

const AGGREGATE_RULE_TYPE = exports.AGGREGATE_RULE_TYPE = 'caf.aggregateRule';
const HASH_ALGO = 'md5';

const checkAggregateRule = function(rule) {
    if (rule.type !== AGGREGATE_RULE_TYPE) {
        const err = new Error('Invalid aggregate rule');
        err['rule'] = rule;
        throw err;
    }
};

/**
 * Computes a content-based identifier for a rule.
 *
 * @see {@link module:caf_security/proxy_security#addRule}.
 *
 * @param {ruleType} rule A rule.
 * @return {string} A unique identifier based on the contents of that rule.
 * @throws {Error} Invalid rule.
 *
 * @memberof! module:caf_security/aggregates
 * @alias computeRuleId
 *
 */
exports.computeRuleId = function(rule) {
    checkAggregateRule(rule);

    const p = [
        AGGREGATE_RULE_TYPE, /** @type aggregateRuleType*/ (rule).alias,
        rule.methods || null
    ];
    const pStr = JSON.stringify(p);
    return crypto.createHash(HASH_ALGO).update(pStr).digest('hex');
};

/**
 * Preprocess an array of rules for quick authorization checks.
 *
 * @param {Object} ca The CA that contains the security plugin.
 * @param {Array.&lt;ruleType>} rules A set of rules to pre-process.
 *
 * @return {ruleEngineType} An engine to speed up checks.
 *
 * @memberof! module:caf_security/aggregates
 * @alias newRuleEngine
 */
exports.newRuleEngine = function(ca, rules) {
    /** @type ruleEngineType*/
    const rE = {};
    // inverse lookup table
    const mToMap = {};

    rules = rules || [];

    rules.forEach(function(rule) {
        checkAggregateRule(rule);
        let method = (rule.methods ? rule.methods : '*');
        method = (Array.isArray(method) ? method : [method]);
        method.forEach(function(m) {
            let value = mToMap[m];
            value = (value ? value : []);
            value.push(/** @type aggregateRuleType*/ (rule).alias);
            mToMap[m] = value;
        });
    });

    const isAuthorizedOne = function($$, aggArray, name) {
        if (Array.isArray(aggArray)) {
            return aggArray.some(function(x) {
                const agg = $$[x];
                if (agg) {
                    return (agg.getAll(name).length > 0);
                } else {
                    return false;
                }
            });
        } else {
            return false;
        }
    };

    rE.isAuthorized = function(caOwner, caLocalName, method) {
        if (ca.$.sharing) {
            const fullName = json_rpc.joinName(caOwner, caLocalName);
            const $$ = ca.$.sharing.$.proxy.$;
            const wild = mToMap['*'];
            if (wild) {
                if (isAuthorizedOne($$, wild, caOwner)) {
                    return true;
                }
                if (isAuthorizedOne($$, wild, fullName)) {
                    return true;
                }
            }
            const m = mToMap[method];
            if (m) {
                if (isAuthorizedOne($$, m, caOwner)) {
                    return true;
                }
                if (isAuthorizedOne($$, m, fullName)) {
                    return true;
                }
            }
        }
        return false;
    };

    return rE;
};

/**
 * Checks whether a CA is authorized to make a method call.
 *
 * @param {string} caOwner The owner of the calling CA.
 * @param {string} caLocalName The local name of the calling CA.
 * @param {string} method A method to authorize.
 * @param {ruleEngineType} rE A data structure to speed up checks.
 *
 * @return {boolean} True if authorized.
 *
 * @memberof! module:caf_security/aggregates
 * @alias isAuthorized
 */
exports.isAuthorized = function(caOwner, caLocalName, method, rE) {
    return rE.isAuthorized(caOwner, caLocalName, method);
};


/**
 * Constructor for a rule that uses an `AggregateMap` to represent a linked
 * local namespace.
 *
 * Note that aggregate rules are only active if the corresponding
 * `AggregateMap` has been added using the `caf_sharing` plugin.
 *
 *  @see {@link external:caf_sharing}
 *  @see {@link module:caf_security/proxy_security#addRule}.
 *
 *  @param {(Array.&lt;string>|string)=} methods Methods to enable.
 *  @param {string} aggregateMapAlias The alias that we used to
 * instantiate the `AggregateMap`.
 *
 *  @return {ruleType} An authorization rule.
 *
 * @memberof! module:caf_security/aggregates
 * @alias newAggregateRule
 */
exports.newAggregateRule = function(methods, aggregateMapAlias) {
    /** @type aggregateRuleType*/
    const result = {type: AGGREGATE_RULE_TYPE, alias: aggregateMapAlias};
    if (methods) {
        result.methods = methods;
    }
    return result;
};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-caf_security_aggregates.html">caf_security/aggregates</a></li><li><a href="module-caf_security_main.html">caf_security/main</a></li><li><a href="module-caf_security_plug_ca_security.html">caf_security/plug_ca_security</a></li><li><a href="module-caf_security_plug_security.html">caf_security/plug_security</a></li><li><a href="module-caf_security_proxy_security.html">caf_security/proxy_security</a></li><li><a href="module-caf_security_rules.html">caf_security/rules</a></li><li><a href="module-caf_security_tokens.html">caf_security/tokens</a></li><li><a href="module-caf_security_utils.html">caf_security/utils</a></li></ul><h3>Externals</h3><ul><li><a href="external-caf_components_gen_plug.html">caf_components/gen_plug</a></li><li><a href="external-caf_components_gen_plug_ca.html">caf_components/gen_plug_ca</a></li><li><a href="external-caf_components_gen_proxy.html">caf_components/gen_proxy</a></li><li><a href="external-caf_sharing.html">caf_sharing</a></li><li><a href="external-caf_sharing_AggregateMap.html">caf_sharing/AggregateMap</a></li></ul><h3><a href="global.html">Global</a></h3>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.6</a> on Mon Feb 01 2021 15:33:07 GMT-0800 (Pacific Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
